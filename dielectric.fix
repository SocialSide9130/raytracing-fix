module Dielectric;

import Material;

import Random::{ Random, generate_F64_2 };

import Ray;
import Hittable;
import Vec3;
import MathUtil;

type Dielectric = struct { refraction_index : F64 };

impl Dielectric : Specular {
    reflect = |v, n, dielectric| (
        v - (2.0 * v.dot(n)).times(n)
    );
}

impl Dielectric : Material {
    scatter = |random, ray_in, hit_record, dielectric| (
        let attenuation : Color = make_vec3(1.0, 1.0, 1.0);
        let etai_over_etat : F64 = if (hit_record.@front_face) {
            1.0 / dielectric.@refraction_index
        } else {
            dielectric.@refraction_index
        };

        let unit_direction : Vec3 = ray_in.@direction.unit;
        let cos_theta = min((-unit_direction).dot(hit_record.@normal), 1.0);
        let sin_theta = sqrt(1.0 - cos_theta * cos_theta);
        let cannot_refract = etai_over_etat * sin_theta > 1.0;
        let (random, prob) = random.generate_F64_2;
        
        let direction = if (cannot_refract || reflectance(cos_theta, etai_over_etat) > prob) {
            dielectric.reflect(unit_direction, hit_record.@normal)
        } else {
            refract(unit_direction, hit_record.@normal, etai_over_etat)
        };

        let scattered = make_ray(hit_record.@p, direction);

        Option::some $ (random, attenuation, scattered)
    );
}

namespace Dielectric {
    refract : Vec3 -> Vec3 -> F64 -> Vec3;
    refract = |uv, n, etai_over_etat| (
        let cos_theta = min((-uv).dot(n), 1.0);
        let r_out_parallel = etai_over_etat.times(uv + cos_theta.times(n));
        let r_out_perp = (-sqrt(abs(1.0 - r_out_parallel.squared_length))).times(n);

        r_out_parallel + r_out_perp
    );

    reflectance : F64 -> F64 -> F64;
    reflectance = |cosine, refraction_index| (
        let r0 = (1.0 - refraction_index) / (1.0 + refraction_index);
        let sq = r0 * r0;

        sq + (1.0 - r0) * (1.0 - cosine).pow5
    );
}