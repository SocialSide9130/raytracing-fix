module Dielectric;

import Material;

import Ray;
import Hittable;
import Vec3;
import MathUtil;

type Dielectric = struct { refraction_index : F64 };

impl Dielectric : Material {
    scatter = |random, ray_in, hit_record, dielectric| (
        let etai_over_etat = if (hit_record.@front_face) {
            1.0 / dielectric.@refraction_index
        } else {
            dielectric.@refraction_index
        };

        let unit_direction : Vec3 = ray_in.@direction.unit;
        let refracted = refract(unit_direction, hit_record.@normal, etai_over_etat);
        let scattered = make_ray(hit_record.@p, refracted);

        Option::some $ (random, make_vec3(1.0, 1.0, 1.0), scattered)
    );
}

namespace Dielectric {
    refract : Vec3 -> Vec3 -> F64 -> Vec3;
    refract = |uv, n, etai_over_etat| (
        let cos_theta = min((-uv).dot(n), 1.0);
        let r_out_parallel = etai_over_etat.times(uv + cos_theta.times(n));
        let r_out_perp = (-sqrt(abs(1.0 - r_out_parallel.squared_length))).times(n);

        r_out_parallel + r_out_perp
    );
}