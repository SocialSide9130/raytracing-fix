module Main;

import Random::{ Random, generate_F64_2, init_by_seed };
import MathUtil;

import Camera;
import Vec3;
import Ray;
import Hittable;
import Sphere;

import Material;
import Lambertian;
import Metal;
import Dielectric;

ray_color : Random::Random -> Ray -> I64 -> HittableObject -> (Random::Random, Color);
ray_color = |random, ray, depth, world| (
    let hit_record = world.hit(0.001, F64::infinity, ray);

    if (depth <= 0) {
        (random, make_vec3(0.0, 0.0, 0.0))
    };
    
    if (hit_record.is_some) {
        let hit_record = hit_record.as_some;
        let scatter = hit_record.@material.scatter(random, ray, hit_record);

        if (scatter.is_some) {
            let (random, attenuation, scattered) = scatter.as_some;
            let (random, color) = world.ray_color(random, scattered, depth - 1);

            (random, attenuation.multiply(color))
        };

        (random, zero)
    };

    let unit_direction : Vec3 = ray.@direction.unit;
    let t = 0.5 * (unit_direction.@y + 1.0);
    let c : Color = make_vec3(1.0, 1.0, 1.0);
    let x : Color = make_vec3(0.5, 0.7, 1.0);

    (random, (1.0 - t).times(c) + t.times(x))
);

output_ppm : Random::Random -> IO () = |rand| (
    let aspect_ratio : F64 = 16.0 / 9.0;
    let image_width = 384;
    let image_height = (image_width.to_F64 / aspect_ratio).to_I64;
    let samples_per_pixel : I64 = 100;
    let max_depth : I64 = 50;
    let r = cos(pi / 4.0);

    let world : HittableObject = HittableObject::hittable_list([
                                    HittableObject::sphere(
                                        make_sphere(make_vec3(-r, 0.0, -1.0),
                                        r,
                                        MaterialObject::lambertian(
                                            Lambertian { albedo : make_vec3(0.0, 0.0, 1.0) }
                                        ))
                                    ),
                                    HittableObject::sphere(
                                        make_sphere(make_vec3(r, 0.0, -1.0),
                                        r,
                                        MaterialObject::lambertian(
                                            Lambertian { albedo : make_vec3(1.0, 0.0, 0.0) }
                                        ))
                                    )
                                ]);

    let lookfrom = make_vec3(3.0, 3.0, 2.0);
    let lookat = make_vec3(0.0, 0.0, -1.0);
    let vup = make_vec3(0.0, 1.0, 0.0);
    let aperture = 2.0;
    let dist_to_focus = (lookfrom - lookat).length;

    let camera : Camera = make_camera(
        lookfrom,
        lookat,
        vup,
        20.0,
        aspect_ratio,
        aperture,
        dist_to_focus
    );

    "P3".println;;
    (image_width.to_string + " " + image_height.to_string).println;;
    "255".println;;

    loop_m(image_height-1, |y : I64| (
        if y < 0 {
            break_m $ ()
        };

        pure(debug_eprint $ "\rScanlines remaining: " + y.to_string + "   ");;

        loop_m(0, |x : I64| (
            if x >= image_width { break_m $ () };

            let pixel_color : Color = loop((0, rand, zero : Color), |(index, rand, pixel_color)| (
                let (rand, random_value_0) = generate_F64_2(rand);
                let (rand, random_value_1) = generate_F64_2(rand);
                let u = (x.to_F64 + random_value_0) / (image_width - 1).to_F64;
                let v = (y.to_F64 + random_value_1) / (image_height - 1).to_F64;

                let (rand, r) = camera.get_ray(u, v, rand);
                let (rand, c) = ray_color(rand, r, max_depth, world);
                
                if (index == 100) {
                    break $ pixel_color
                };

                continue $ (index + 1, rand, pixel_color + c)
            ));

            println(pixel_color.get_string_after_sampling(samples_per_pixel));;
            continue_m $ x + 1
        ));;
        continue_m $ y - 1
    ));;

    pure $ debug_eprintln("\nDone")
);

main : IO () = (
    let random : Random::Random = init_by_seed(0_U64);

    output_ppm(random)
);