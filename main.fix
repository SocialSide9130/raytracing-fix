module Main;

import Random::{ Random, generate_F64_2, init_by_seed };
import MathUtil;

import Camera;
import Vec3;
import Ray;
import Hittable;
import Sphere;

import Material;
import Lambertian;
import Metal;
import Dielectric;

random_sphere : I64 -> I64 -> Random::Random -> (Random::Random, Option HittableObject);
random_sphere = |a, b, random| (
    let (random, choose_mat) = random.generate_F64_2;
    let (random, r1) = random.generate_F64_2;
    let (random, r2) = random.generate_F64_2;

    let center : Point3 = make_vec3(a.to_F64 + 0.9 * r1, 0.2, b.to_F64 + 0.9 * r2);

    let (random, sphere_or_none) = if ((center - make_vec3(4.0, 0.2, 0.0)).length > 0.9) {
        if (choose_mat < 0.8) {
            let (random, r1) = random.random_in_range(0.0, 1.0) : (Random::Random, Vec3);
            let (random, r2) = random.random_in_range(0.0, 1.0) : (Random::Random, Vec3);
            let albedo = r1.multiply(r2);

            (
                random,
                Option::some(
                    HittableObject::sphere(
                        make_sphere(center, 0.2, MaterialObject::lambertian(Lambertian { albedo : albedo }))
                    )
                )
            )
        } else if (choose_mat < 0.95) {
            let (random, albedo) = random.random_in_range(0.5, 1.0) : (Random::Random, Vec3);
            let (random, fuzz) = random.random_in_range(0.0, 0.5) : (Random::Random, F64);

            (
                random,
                Option::some(
                    HittableObject::sphere(
                        make_sphere(center, 0.2, MaterialObject::metal(Metal { albedo : albedo, fuzz : fuzz }))
                    )
                )
            )
        } else {
            (
                random,
                Option::some(
                    HittableObject::sphere(
                        make_sphere(center, 0.2, MaterialObject::dielectric(Dielectric { refraction_index : 1.5 }))
                    )
                )
            )
        }
    } else {
        (random, Option::none $ ())
    };

    (random, sphere_or_none)
);

random_scene : Random::Random -> (Random::Random, HittableObject);
random_scene = |random| (
    let world : Array HittableObject = [
        HittableObject::sphere(
            make_sphere(
                make_vec3(0.0, -1000.0, 0.0),
                1000.0,
                MaterialObject::lambertian(Lambertian { albedo : make_vec3(0.5, 0.5, 0.5) })
            )
        ),
    ];

    let coordinates = range(-11, 11).flat_map(|a| range(-11, 11).map(|b| (a, b)));

    let (random, world) = coordinates.fold((random, world), |(a, b), (random, world)| (
        let (random, sphere) = random.random_sphere(a, b);

        if (sphere.is_some) {
            (random, world.push_back(sphere.as_some))
        } else {
            (random, world)
        }
    ));

    let sphere1 = HittableObject::sphere(
        make_sphere(
            make_vec3(0.0, 1.0, 0.0),
            1.0,
            MaterialObject::dielectric(Dielectric { refraction_index : 1.5 })
        )
    );
    let sphere2 = HittableObject::sphere(
        make_sphere(
            make_vec3(-4.0, 1.0, 0.0),
            1.0,
            MaterialObject::lambertian(Lambertian { albedo : make_vec3(0.4, 0.2, 0.1) })
        )
    );
    let sphere3 = HittableObject::sphere(
        make_sphere(
            make_vec3(4.0, 1.0, 0.0),
            1.0,
            MaterialObject::metal(Metal { albedo : make_vec3(0.7, 0.6, 0.5), fuzz : 0.0 })
        )
    );
    let world = world.append([sphere1, sphere2, sphere3]);

    (random, HittableObject::hittable_list(world))
);

ray_color : Random::Random -> Ray -> I64 -> HittableObject -> (Random::Random, Color);
ray_color = |random, ray, depth, world| (
    let hit_record = world.hit(0.001, F64::infinity, ray);

    if (depth <= 0) {
        (random, make_vec3(0.0, 0.0, 0.0))
    };
    
    if (hit_record.is_some) {
        let hit_record = hit_record.as_some;
        let scatter = hit_record.@material.scatter(random, ray, hit_record);

        if (scatter.is_some) {
            let (random, attenuation, scattered) = scatter.as_some;
            let (random, color) = world.ray_color(random, scattered, depth - 1);

            (random, attenuation.multiply(color))
        };

        (random, zero)
    };

    let unit_direction : Vec3 = ray.@direction.unit;
    let t = 0.5 * (unit_direction.@y + 1.0);
    let c : Color = make_vec3(1.0, 1.0, 1.0);
    let x : Color = make_vec3(0.5, 0.7, 1.0);

    (random, (1.0 - t).times(c) + t.times(x))
);

output_ppm : Random::Random -> IO () = |rand| (
    let aspect_ratio : F64 = 16.0 / 9.0;
    let image_width = 720;
    let image_height = (image_width.to_F64 / aspect_ratio).to_I64;
    let samples_per_pixel : I64 = 100;
    let max_depth : I64 = 50;
    let r = cos(pi / 4.0);

    let (rand, world) = rand.random_scene;

    let lookfrom = make_vec3(13.0, 2.0, 3.0);
    let lookat = make_vec3(0.0, 0.0, 0.0);
    let vup = make_vec3(0.0, 1.0, 0.0);
    let aperture = 0.1;
    let dist_to_focus = 10.0;

    let camera : Camera = make_camera(
        lookfrom,
        lookat,
        vup,
        20.0,
        aspect_ratio,
        aperture,
        dist_to_focus
    );

    "P3".println;;
    (image_width.to_string + " " + image_height.to_string).println;;
    "255".println;;

    loop_m(image_height-1, |y : I64| (
        if y < 0 {
            break_m $ ()
        };

        pure(debug_eprint $ "\rScanlines remaining: " + y.to_string + "   ");;

        loop_m(0, |x : I64| (
            if x >= image_width { break_m $ () };

            let pixel_color : Color = loop((0, rand, zero : Color), |(index, rand, pixel_color)| (
                let (rand, random_value_0) = generate_F64_2(rand);
                let (rand, random_value_1) = generate_F64_2(rand);
                let u = (x.to_F64 + random_value_0) / (image_width - 1).to_F64;
                let v = (y.to_F64 + random_value_1) / (image_height - 1).to_F64;

                let (rand, r) = camera.get_ray(u, v, rand);
                let (rand, c) = ray_color(rand, r, max_depth, world);
                
                if (index == 100) {
                    break $ pixel_color
                };

                continue $ (index + 1, rand, pixel_color + c)
            ));

            println(pixel_color.get_string_after_sampling(samples_per_pixel));;
            continue_m $ x + 1
        ));;
        continue_m $ y - 1
    ));;

    pure $ debug_eprintln("\nDone")
);

main : IO () = (
    let random : Random::Random = init_by_seed(0_U64);

    output_ppm(random)
);