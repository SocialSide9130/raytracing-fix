module Vec3;

import Random::Random;
import MathUtil;

type Vec3 = struct { x : F64, y : F64, z : F64 };

type Color = Vec3;
type Point3 = Vec3;

impl Vec3 : Add {
    add = |v1, v2| (
        Vec3 { x : v1.@x + v2.@x, y : v1.@y + v2.@y, z : v1.@z + v2.@z }
    );
}

impl Vec3 : Sub {
    sub = |v1, v2| (
        Vec3 { x : v1.@x - v2.@x, y : v1.@y - v2.@y, z : v1.@z - v2.@z }
    );
}

impl Vec3 : Neg {
    neg = |v| (
        Vec3 { x : -v.@x, y : -v.@y, z : -v.@z }
    );
}

impl Vec3 : Eq {
    eq = |v1, v2| (
        v1.@x == v2.@x && v1.@y == v2.@y && v1.@z == v2.@z
    );
}

impl Vec3 : Zero {
    zero = Vec3 { x : 0.0, y : 0.0, z : 0.0 };
}

impl Color : ToString {
    to_string = |v| (
        (256.0 * v.red).to_I64.to_string + " " + (256.0 * v.green).to_I64.to_string + " " + (256.0 * v.blue).to_I64.to_string
    );
}

namespace Vec3 {
    red : Vec3 -> F64;
    red = |v| v.@x;
    
    green : Vec3 -> F64;
    green = |v| v.@y;
    
    blue : Vec3 -> F64;
    blue = |v| v.@z;

    make_vec3 : F64 -> F64 -> F64 -> Vec3;
    make_vec3 = |x, y, z| (
        Vec3 { x : x, y : y, z : z }
    );

    times : Vec3 -> F64 -> Vec3;
    times = |v, t| (
        Vec3 { x : t * v.@x, y : t * v.@y, z : t * v.@z }
    );

    div_by : F64 -> Vec3 -> Vec3;
    div_by = |t, v| (
        (1.0/t).times(v)
    );

    dot : Vec3 -> Vec3 -> F64;
    dot = |v1, v2| (
        v1.@x * v2.@x + v1.@y * v2.@y + v1.@z * v2.@z
    );

    cross : Vec3 -> Vec3 -> Vec3;
    cross = |v1, v2| (
        Vec3 {
            x : v1.@y * v2.@z - v1.@z * v2.@y,
            y : v1.@z * v2.@x - v1.@x * v2.@z,
            z : v1.@x * v2.@y - v1.@y * v2.@x
        }
    );

    length : Vec3 -> F64;
    length = |v| (
        sqrt(v.squared_length)
    );

    squared_length : Vec3 -> F64;
    squared_length = |v| (
        v.dot(v)
    );

    unit : Vec3 -> Vec3;
    unit = |v| (
        v.div_by(v.length)
    );

    get_string_after_sampling : I64 -> Color -> String;
    get_string_after_sampling = |samples_per_pixel, color| (
        let scale = 1.0 / samples_per_pixel.to_F64;
        let r = (color.red * scale).sqrt.clamp(0.0, 0.999);
        let g = (color.green * scale).sqrt.clamp(0.0, 0.999);
        let b = (color.blue * scale).sqrt.clamp(0.0, 0.999);
        let c = Vec3 { x : r, y : g, z : b };

        c.to_string
    );

    random_in_range : F64 -> F64 -> Random::Random -> (Random::Random, Vec3);
    random_in_range = |min, max, random| (
        let (random, x) = random.random_in_range(min, max) : (Random::Random, F64);
        let (random, y) = random.random_in_range(min, max) : (Random::Random, F64);
        let (random, z) = random.random_in_range(min, max) : (Random::Random, F64);

        (random, make_vec3(x, y, z))
    );

    random_in_unit_sphere : Random::Random -> (Random::Random, Vec3);
    random_in_unit_sphere = |random| (
        let (random, p) = random.random_in_range(-1.0, 1.0) : (Random::Random, Vec3);

        if (p.squared_length < 1.0) {
            (random, p)
        } else {
            random_in_unit_sphere(random)
        }
    );

    random_unit_vector : Random::Random -> (Random::Random, Vec3);
    random_unit_vector = |random| (
        let (random, a) = random.random_in_range(0.0, 2.0 * pi)  : (Random::Random, F64);
        let (random, z) = random.random_in_range(-1.0, 1.0)  : (Random::Random, F64);
        let r = sqrt(1.0 - z * z);

        (random, make_vec3(r * cos(a), r * sin(a), z))
    );
}
