module Vec3;

type Vec3 = struct { x : F64, y : F64, z : F64 };

type Color = Vec3;
type Point3 = Vec3;

namespace F64 {
    sqrt : F64 -> F64;
    sqrt = |v| FFI_CALL[F64 sqrt(F64), v];
}

impl Vec3 : Add {
    add = |v1, v2| (
        Vec3 { x : v1.@x + v2.@x, y : v1.@y + v2.@y, z : v1.@z + v2.@z }
    );
}

impl Vec3 : Sub {
    sub = |v1, v2| (
        Vec3 { x : v1.@x - v2.@x, y : v1.@y - v2.@y, z : v1.@z - v2.@z }
    );
}

impl Vec3 : Neg {
    neg = |v| (
        Vec3 { x : -v.@x, y : -v.@y, z : -v.@z }
    );
}

impl Vec3 : Eq {
    eq = |v1, v2| (
        v1.@x == v2.@x && v1.@y == v2.@y && v1.@z == v2.@z
    );
}

impl Vec3 : Zero {
    zero = Vec3 { x : 0.0, y : 0.0, z : 0.0 };
}

impl Color : ToString {
    to_string = |v| (
        (255.99 * v.red).to_I64.to_string + " " + (255.99 * v.green).to_I64.to_string + " " + (255.99 * v.blue).to_I64.to_string
    );
}

namespace Vec3 {
    red : Vec3 -> F64;
    red = |v| v.@x;
    
    green : Vec3 -> F64;
    green = |v| v.@y;
    
    blue : Vec3 -> F64;
    blue = |v| v.@z;

    times : Vec3 -> F64 -> Vec3;
    times = |v, t| (
        Vec3 { x : t * v.@x, y : t * v.@y, z : t * v.@z }
    );

    div_by : F64 -> Vec3 -> Vec3;
    div_by = |t, v| (
        (1.0/t).times(v)
    );

    dot : Vec3 -> Vec3 -> F64;
    dot = |v1, v2| (
        v1.@x * v2.@x + v1.@y * v2.@y + v1.@z * v2.@z
    );

    cross : Vec3 -> Vec3 -> Vec3;
    cross = |v1, v2| (
        Vec3 {
            x : v1.@y * v2.@z - v1.@z * v2.@y,
            y : v1.@z * v2.@x - v1.@x * v2.@z,
            z : v1.@x * v2.@y - v1.@y * v2.@x
        }
    );

    length : Vec3 -> F64;
    length = |v| (
        sqrt(v.squared_length)
    );

    squared_length : Vec3 -> F64;
    squared_length = |v| (
        v.dot(v)
    );

    unit : Vec3 -> Vec3;
    unit = |v| (
        v.div_by(v.length)
    );
}
